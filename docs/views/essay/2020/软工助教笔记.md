---
title: 软工助教笔记
date: 2020-10-23
tags:
 - Huawei
 - Software Engineering
categories: 
 - essay
---

## 软工助教笔记



> **开发流程：** 
>
> -  配置管理
> -  代码检查
> -  编译构建
> -  测试管理
> -  部署服务
> -  发布服务
> -  持续交付流水线



## 敏捷开发

> **敏捷开发宣言：**  为我们在开发过程中发现更好的软件开发方法，并帮助他人这样做。通过这项工作我们得到如下评估：
>
> - 个体和交互胜过过程和工具
> - 编写软件胜过书写详尽的文档
> - 用户合作胜过合同谈判
> - 响应变更胜过遵循计划
>
> 也就是说，虽然右边的项有价值，但我们更重视左边的项的价值。



> **敏捷开发原则：** 
>
> - 客户参与
> - 增量式交互
> - 人非过程
> - 接受变更
> - 保持简单性

###  一、XP 极限编程

​      在极限编程中，所有需求都被表示为脚本(scenario 称为用户故事情节)，它将直接被实现为一系列任务。程序员两两配对工作，在写代码之前为每个任务开发测试。在新的代码加入到系统中时，所有的测试必须成功执行。

> **极限编程的原则：** 
>
> - 增量式规划：需求记录在==脚本卡==中，并设置优先级。
> - 小版本发布：首先开发能提供业务价值的一个最小的有用集合。
> - 简单设计：只进行有限的能满足当前需求的设计，不要追求太多。
> - 测试优先的开发：功能实现之前，采用一个自动单元测试框架来编写对此新功能的测试。
> - 重构：所有程序员连续地对代码重构，发现有可能改善的代码就去做。
> - 结对编程
> - 集体所有：配对的开发人员参与系统的所有方面工作，所以不会存在技术孤岛。
> - 连续集成：任务一完成，将它集成到大系统中。
> - 可持续的节奏：大量超时是不能接受的。
> - 在场客户：系统最终用户的代表应该全程配合XP团队。

#### 1. 极限编程中的测试

许多增量开发的测试过程是很不规范的，为避免一些测试和系统验证方面的问题，XP方法更强调测试过程。

> **XP测试的关键特性如下：** 
>
> - ==测试优先的开发：XP先写测试程序，再写代码。==
> - 来自脚本的增量式的测试开发
> - 用户参与测试开发和有效验证
> - 自动测试系统的使用



##### (1) 测试优先的开发

先写测试隐含地定义了界面和要求开发的功能的行为描述，减少了对需求和界面的误解。

> - 在XP中的用户需求表达为脚本或故事情节，用户再对需求进行优先权排序以进行开发。
> - 开发团队评估每一个脚本并将其分解任务(脚本卡-->任务卡)。
> - 每一个任务生成一个或多个单元测试来检查此任务中所描述的实现。

如下表：

| 测试用例：剂量检测                                        |
| :-------------------------------------------------------- |
| **输入：**                                                 |
| 1. 以mg为单位的一个数，表示单次服药剂量。                 |
| 2. 一个数，表示每天服药的次数。                           |
| **测试：**                                                 |
| 1. 输入测试，这里的单次服药剂量是正确的，但服药次数太多。 |
| 2. 输入测试，这里的单次服药剂量太大或太小。               |
| 3. 输入测试，这里的单次服药剂量 x 服药次数太大或太小。    |
| 4. 输入测试，这里的单次服药剂量 x 服药次数在允许范围内。  |
| **输出：**                                                 |
| 显示正确或者错误信息，指示剂量在正常范围或超出安全范围。  |

**在测试过程中用户的作用是：** 将要在系统的下一个版本中实现的故事情节开发接收测试。



##### (2) 自动测试系统

​     ==测试优先的开发和自动测试系统的使用是XP方法的主要优势。==在任务实现之前就将测试写成了可执行的组件，这个测试组件应该是独立的，应该模拟待测试的输入提交没并且应该检查结果。自动测试框架如JUnit是这样一个系统，它使编写可执行测试程序和提交测试程序集编的容易。

**缺点：** 

测试优先的开发和自动测试通常导致要编写和执行大量的测试程序，然而，这种方法并不一定使程序得到彻底的测试。有如下3个原因：

1. 程序员更喜欢编程而不是测试，有时在写测试时会走捷径。
2. 有一些测试是非常难写的。
3. 对异族测试的完整性判断也是困难的。

---



#### 2. 结对编程

**优点：** 

1. 它支持共同拥有软件和共同对系统负责。
2. 它担任了非正式的复查过程。
3. 它有助于支持重构

**缺点：** 

​		对更有经验的程序员来说，结对编程会比单个人编程损失生产力。结对编程是有一些质量效益，但却不足以抵消它的开销。

但信息的共享在结对编程时是很重要的，==因为当有团队成员离开时，它降低了整体风险。就其本身来说，这可能就是结对编程的价值所在。==

### 二、Scrum



Scrum方法不同于项目管理的标准方法(用于计划驱动)，Scrum是一个通用的敏捷方法，但它主要是注重迭代开发管理，而不是管理敏捷软件工程的专门技术方法。

![scrum](http://5b0988e595225.cdn.sohucs.com/images/20181109/84ac631554ee4b5591b643de6bc6f283.png)

**Scrum有3个阶段：** 

1. **规划纲要阶段：** 建立大致的项目目标和设计软件体系结构。
2. **一系列冲刺循环：** 每个循环开发出一个系统增量
3. **项目结束阶段：** 总结项目，完善文档，如系统帮助和用户手册，并总结经验

​      **Scrum的创新在于它的中心阶段，也就是冲刺循环。一个循环是一个计划单元，需要的工作有：评估，特征的选择和开发，软件实现。**循环的最后一个阶段，所开发的全部功能都将交付给信息持有者。

> **冲刺循环过程的主要特点如下：** 
>
> 1. 冲刺有一个固定的长度，一般是2~4周。在XP中，对应一个系统版本的开发。
> 2. 规划的起点是所谓的backlog（积压的任务），是项目中要完成的工作清单。在评估阶段，这些积压的任务经过审查，对它们进行优先级排序并进行风险的指派。此过程用户都紧密参与。
> 3. 在选择阶段，项目团队的所有人都要参加，和用户一起选择在冲刺循环中要开发的特性和功能。
> 4. 一旦这些都得到同意，团队将组织进行软件开发。
> 5. 冲刺循环结束，对已做工作复查并交付给用户。

> 在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。每日站立会议有一些具体的指导原则：
>
> 会议准时开始。对于迟到者团队常常会制定惩罚措施（例如罚款，做[俯卧撑](https://baike.baidu.com/item/俯卧撑)，在脖子上挂橡胶鸡玩具）欢迎所有人参加，但只有"猪"可以发言。不论团队规模大小，会议被限制在15分钟。所有出席者都应站立。（有助于保持会议简短）会议应在固定地点和每天的同一时间举行。在会议上，每个团队成员需要回答三个问题：
>
> ==你完成了哪些工作？以后你打算做什么？完成你的目标是否存在什么障碍？（Scrum主管需要记下这些障碍）==
>
> 每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。
>
> Scrum提倡所有团队成员坐在一起工作，进行口头交流，以及强调项目有关的规范（disciplines），这些有助于创造自我组织的团队。
>
> Scrum的一个关键原则是承认客户可以在项目过程中改变主意，变更他们的需求，而预测式和计划式的方法并不能轻易地解决这种不可预见的需求变化。同样，Scrum采用了经验方法– 承认问题无法完全理解或定义，而是关注于如何使得开发团队快速推出和响应不断出现的需求的能力最大化。 



## Git

Git是一款开源的分布式版本控制系统(Distributed Version Control System)，诞生于2002年，有Linux之父Linus Torvalds带领的Linux开源社区开发完成。初衷是用其管理Linux内核的庞大的开源代码。

Git的设计理念包括：

- 速度快
- 出色的合并跟踪能力
- 灵活强大的分支策略
- 便于编码协同
- 支持代码审核机制
- 代码安全性高

### Git vs SVN

1. **版本库的安全性高**
   - **Git**
     - 分布式系统，每个用户相当于一个备份
     - 通过SHA1哈希保证数据的完整性，防止恶意篡改
   - SVN
     - 集中式存在单点故障风险
     - 服务器端历史数据被篡改时，客户端难以发现
2. **分支功能强大**
   - **Git**
     - 便于查询和追溯分支间的提交历史
     - 支持双向合并
   - SVN
     - 分支不支持提交隔离
     - 一次提交可同时更改主线和分支的内容，无法查询和追溯分支间额提交历史
3. **更灵活的发布控制**
   - **Git**
     - 设置只有发布管理员才有权限推送的版本库或者分支，用于稳定发布版本的维护
     - 设置只有项目经历、模块管理员才有权推送的版本库或者分支，用于整合测试
4. **隔离开发、提交审核**
   - **Git**
     - 支持团队成员自建分支和版本库
     - 通过合并请求或从成员个人版本库、分支获取提交，从提交说明、代码规范等方面对提交逐一审核
5. **对合并更好的支持：更少的冲突和更好的解决冲突**
   - **Git**
     - 基于DAG（有向非环图）的设计比SVN的线性提交提供更好的合并追踪，避免不必要的冲突，提高工作效率
     - 基于对内容的追踪而非对文件名追踪，所以遇到一方或者双方对文件名更改时，Git能够很好进行自动合并或提供工具辅助合并。而SVN遇到同样问题会产生树冲突，解决起来很麻烦



### Git基本概念



> - **工作拷贝（工作目录）：**  用于存放产品开发数据本地工作的目录
> - **索引（Index）：**  用于存放待提交数据的缓存 （基本只要前六位就可以唯一标识了）
> - **本地库：** 远端库的一个完整的拷贝，包括所有文件的修改记录，分支等
> - **远端库：** 本地库clone来源
> - **中心库：** 远端库的一种，公司级存放某个项目所有产品数据的仓库
> - **快照（snapshot）：** 版本库某个时间点所有文件的集合
> - **全球版本号（commitID）：** Git库的版本号是通过SHA-1算法根据库中的所有内容计算出一个40位的哈希值，这个哈希值是全球唯一的，==基本只要前六位就可以唯一标识了==。

#### 文件状态介绍：

- **UNtracked files：** 未被跟踪的文件，一般指新添加的文件
- **Change not staged for commit：** 已修改的文件，包括modified和deleted状态
- **Change to be commit：** 已缓冲的文件，即已add的文件，包括modified、deleted和new file状态
- **Nothing to commit：** 已提交的文件，即已commit的文件



#### Git 操作模式

![image-20201014155845788](E:\Typora_Imagine\image-20201014155845788.png)



#### Git 分支

**分支：** 

- 本质上是个指向commit对象的可变指针
- 分支的默认名字为master
- 每次提交的时候都会自动向前移动
- **作用：** 从某个提交对象往回看的历史

![image-20201014161845635](E:\Typora_Imagine\image-20201014161845635.png)



##### 新建分支

**示例1：** 新建一个testing分支

```bash
$ git branch testing
```

![image-20201014162352687](E:\Typora_Imagine\image-20201014162352687.png)

##### 如何识别当前分支

- HEAD指针
- **示例2：** 切换当前分支

```bash
$ git checkout testing
```

![image-20201014162606594](E:\Typora_Imagine\image-20201014162606594.png)



- **示例3：** 做一次提交

```bash
$ vim test.rb
$ git commit -a -m 'made a change'
```

- 每次提交后HEAD随着分支一起向前移动

![image-20201014163013617](E:\Typora_Imagine\image-20201014163013617.png)





- **示例4：** 切回master分支

```bash
$ git checkout master
```

![image-20201014163224206](E:\Typora_Imagine\image-20201014163224206.png)



- **示例5：** 在master分支上做一次提交

```bash
$ vim test.rb
$ git commit -a -m 'made other changes'
```

![image-20201014163407250](E:\Typora_Imagine\image-20201014163407250.png)







## 实验二 持续开发与集成

### 一、代码托管

#### 1.使用CloudIDE修改和提交代码

1. 登录DevCloud，==单击==“**工作>工作项**”，进入“**Backlog**”页面。找到Story“作为用户应该可 以查看、查询所有门店网络”，记录该Story的**编号**。
2. ====单击==页面上方导航“代码>代码托管”，进入代码托管服务。找到样例项目预置的代码仓库 “phoenix-sample”，==单击==图标![image-20201018225920205](E:\Typora_Imagine\image-20201018225920205.png) ，跳转至CloudIDE。==
3. 等待CloudIDE加载完毕。在左侧导航中找到文件“**/vote/templates/index.htm**l”并==打开==，在179行**添加**菜单“**门店网络**”。
4. 提交修改至代码仓库。==单击==左侧边栏图标 ![image-20201018230003444](E:\Typora_Imagine\image-20201018230003444.png)，==打开==**Git**功能。==单击==修改文件后方的图标 ![image-20201018230020349](E:\Typora_Imagine\image-20201018230020349.png) (**git add**)，将修改内容添加进提交内容当中。在输入框中输入提交信息：“**fix #工作项编码 本次提交的注释信息**” (fix #工作项编码 格式要注意，若不一致则不能将提交信息关联到下一个步骤的提交历史查看 )。==单击==打勾图标 ![image-20201018230028994](E:\Typora_Imagine\image-20201018230028994.png) (**git commit**)提交本次修改。==单击==图标![image-20201018230033949](E:\Typora_Imagine\image-20201018230033949.png) ，在下拉列表中==单击==“**Push**”，推送代码到代码仓库。
5. 返回“**代码托管**”页面，==单击==仓库名称进入代码仓库。==选择==“**历史**”页签，即可查看是否提交成功。
6. 跳转至“工作>工作项>Backlog”页面，==单击==Story“作为用户应该可以查看、查询所有门店网络”。在“**关联**”页签中，==单击==“代码提交记录”，即可找到一条记录。



#### 2.使用Git分支+合并请求方式提交代码并进行代码检视

> **通过本节，您将学习如何通过功能分支以及拉取请求的方式完成用户故事的开发，以及在线代码检视。**
>
> 背景：收到新的邮件通知
>
> 发件人：开发经理 
>
> 收件人：凤凰商城开发团队 
>
> 优先级：高 
>
> 主题：凤凰商城开发模式 - 建议使用功能分支+合并请求的方式 
>
> ------------------------------------------------------------------------------------------------------------------------------
>
> Hi 兄弟们：  
>
> 为了保证凤凰商城的稳定运行，我们需要有一个稳定的持续可用的分支“Master”，所以我不建议任何人直接在Master分支上进行代码开发。 请大家在后面的功能开发中统一使用功能分支+合并请求的方式进行功能的开发与合并。 
>
> 而且我建议每一个功能分支的代码，必须经过团队的其他成员评审后，才可以进行合并。 
>
> 谢谢大家的配合。

1. 将master分支==设置==为受**保护分支**。进入项目，====单击====页面上方导航“**代码 > 代码托管**”，进入代码托管服务。====单击====仓库名称，进入代码仓库。

2. ====选择====“**设置**”页签，在左侧导航中====单击====“**仓库管理 > 保护分支管理**”。

3. ====单击====“**新建分支保护**”，根据需要在弹框中==选择==配置，====单击====“确定”保存。

4. 管理分支合并策略。进入代码仓库，==选择==“设置”页签，在左侧导航中==单击==“**基础设置 > 合并请求设置**”。==选择==允许分支合并的**最低评分**，==单击==“确认”保存。可以设置为“0”。

5. ==创建==分支并进行新功能开发。进入代码仓库，==选择==“**分支**”页签，==单击==右上角“**新建分支**”，在弹框中输入分支名称“**feature工作项编号**” (注意：不要有+号等特殊符号) 命名分支，==单击==“确定”保存。

6. 用CloudIDE==打开==代码仓库，==单击==页面**左下角分支名称**，在页面上方的下拉列表中==选择==刚刚==创建==分支。可以看到左下角从“master”变成了新建分支名。

7. ====打开====文件“vote/templates/store-network.html”，添加北京分店地址。

   ```html
   <ul> 
   	<li>北京分店：首都机场1号航站楼出发层靠右直行888米左右右侧</li>
   </ul>
   ```

8. ====打开====文件“vote/templates/index.html”，将179行中“门店网络”菜单连接到“store-network”，手动输入href=“#store-network”。

9. *参考2.1.3 使用CloudIDE修改和提交代码-步骤4操作，将修改的代码推送至代码仓库。*

10. ==创建==合并请求，进入代码仓库，==选择==“**合并请求**”页签，==单击==“**新建合并请求**”。**源分支**==选择==刚刚==创建==的分支，与目标分支==选择==“**master**”，==单击==“**下一步**”。输入标题、描述（选填），==选择==合并人、评审人，==单击==“确定”完成。“合并人”即接受合并请求的人，“评审人”是由合并发起人邀请参与的评审者。对于不合格的合并请求，管理员可以关闭。在评分不够时，无法完成该合并请求。

11. 代码检视以及评分，评审人进入代码仓库后，在“**合并请求**”页签中找到需要评审的合并请求，==单击==该请求，查看合并请求详情。评审者可以在“合并请求详情”页签中**发表评论、发表讨论，对合并请求进行评分**。

    也可以在文件变更页签，针对某一行代码发表讨论。评论与讨论的区别在于：评论无需回复并解决。而讨论是一个需要解决的问题。在评论记录里，可以看到差别。

    *开发人员在“合并请求详情”页面可查评论/讨论记录。*

12. 用CloudIDE==打开==代码仓库，根据建议修改新分枝代码，并参考2.1.3使用CloudIDE修改和提交代码-步骤4操作，**将修改的代码推送至代码仓库**。

    *返回代码仓库，在讨论详情中输入回复信息，并==单击==“回复并解决”*

13. 使用另一账号**提交评分**。若只有一个账号，请将允许分支合并的**最低评分设置为2分**。

14. 合并人进入代码仓库后，在“**合并请求**”页签中找到需要评审的合并请求，==单击==该请求，查看合并请求详情。==选择==“**删除源分支合入**”，系统将提示“合并成功”。

15. 此时，列表中将显示已合并。



###  二、代码检查确保编码规范



#### 1.配置代码检查任务并执行  5min

1. “**代码 > 代码检查**”，进入代码检查服务。==单击==代码检查任务“**phoenix-codecheckworker**”，进入“代码检查详情”页面。
2. ==选择==“**设置**”页签，在页面左侧导航中==单击==“**规则集**”。规则集中默认包含的语言是“Java”。 ==单击==图标 重新获取代码仓库语言，在刷新的列表中将**Python语言对应的开关==打开==**
3. 启动代码检查任务。进入代码检查任务“phoenix-codecheckworker”的“**代码检查详情**”页面。==单击==“**开始检查**”，启动代码检查任务。当页面提示“分支" master"最近一次检查成功！”，表示任务执行成功。

### 2.分析代码检查结果并修复问题 3min

1. *分析代码检查报表。进入代码检查任务“phoenix-codecheckworker”的“代码检查详情”页面。成功执行代码检查任务，**查看检查结果**。*
2. *在代码检查任务“**设置 > 质量门禁**”页面中，默认配置“致命问题数<=0”和“严重问题数<=0”，从上图可以看出，检查结果不符合门禁要求，因此门禁检查结果显示为“Failed”。*
3. *==单击==“**代码问题**”页签，页面中列出问题的严重级别、状态、所属文件等信息。*
4. *可根据需要对代码进行修改。例如：下图中的问题，是在代码里Connection没有关闭可 能会引起的资源泄漏问题，属于非常严重的问题，需要尽快修复。*
5. *==单击==问题卡片，页面右侧将滑出窗口。==单击==“**修改建议**”，可查看系统对此问题的修改建 议。**==单击==窗口上方的图片，可进入相应的代码文件修改代码**。==单击==“未解决”，可将此问 题的状态设置为“已解决”或“已忽略”。*



#### 3.配置和管理代码检查规则集 5min

1. ==创建==自定义检查规范。进入**代码检查**服务，==选择==“**规则集**”页签，在下拉列表中==选择==“**Java**” 。在过滤出的列表中找到规则集“**关键检查规则集**”，==单击==图标 ，在下拉列表中==选择==“**复制**”。在弹框中输入新规则集名称为“**phoenix-java-ruleset**”，==单击==“确定”保存。
2. 系统自动进入新建规则集的“**规则集配置**”页面。通过搜索框搜索规则“Loops should not be infinite”，取消勾选此规则，==单击==“保存”。由于这里凤凰团队采用了取巧的方案临时支持功能是实时展示，暂时可以关闭此问题。
3. 启用自定义检查规范。进入代码检查任务“phoenix-codecheckworker”的“代码检查详情”页面。==选择==“**设置**”页签，在页面左侧导航中==单击==“**规则集**”。在Java语言规则集中，勾选规则集“**phoenix-java-rule-set**”。
4. 启动代码检查任务，任务成功执行后，再次查看检查结果。此时的检查结果忽略了规则“ Loops should not be infinite”，检查出来的问题是团队关心的问题，应该尽快修复掉。







## 实验三 持续测试与反馈

### 一、使用追溯视图进行需求驱动的测试

1. 进入项目，单击页面上方导航“测试 > 测试设计”，进入“测试设计”页面。若您导航中没有“测试设计”，请点击“体验新版云测”，进入新版云测页面后，再选择“测试设计”页面。  ==30s==

2. 单击页面左侧菜单“需求目录”，逐层展开需求树，找到Story“作为用户应该可以查看、查询所有门店网络”。单击图标 ，选择“新建测试用例”。==10s==

   输入名称“门店网络查询”，选择模块“门店网络”、迭代“迭代4”，处理人。添加以下测试步骤与预期结果，单击“保存”。==3min==

   | **测试步骤**     | **预期结果**                                                 |
   | ---------------- | ------------------------------------------------------------ |
   | 打开凤凰商城首页 | 页面正常显示。                                               |
   |                  | 进入“门店网络”界面，页面中存在省份筛选，页面最下面显示推荐门店信息。 |
   | 选择省份“山东”   | 列出山东省的门店信息列表，门店信息包括（地址、电话）。       |

   按照同样的方式，完成下面两个用户故事的测试用例设计，单击页面左侧菜单“需求目录“，逐层展开需求树，Feature"促销管理"，找到以下两个Story，新建与其关联的测试用例。测试用例的名称与步骤自定义即可。  ==6min==

   - 作为管理员应该可以添加限时打折

   - 作为管理员应该可以添加团购活动

   

### 二、 使用测试套件进行迭代测试规划



1. 进入项目，单击页面上方导航“测试 > 测试执行”。单击“测试套件”页签，单击右上角“新建”。==10s==

2. 输入名称“迭代4”，单击“+添加用例”。在弹框中单击图标 筛选迭代“迭代4”，勾选全部筛选出的用例，单击“确定”。==1min==

3. > 背景 
   >
   > 测试经理：我已经设计完成用例，并分配给了对应的测试人员，但是现在我们的测试用例流程中并没有用例设计完成的状态标识。 
   >
   > 建议在用例的流程中添加“已分配”状态，用来表示用例已经设计完成，并分配给了对应的测试人员，可以进行用例执行。

   进入项目，单击页面上方导航“设置 > 云测设置”。选择“功能用例自定义”页签，单击“添加状态”，输入“已分配”，单击“确定”保存。==1mins==

4. 返回“测试设计”页面，勾选上节新建的测试用例，单击页面下方“修改”，在弹框中选择状态“已分配”，单击“确定”保存。==30s==



### 三、使用测试用例和测试套件视图进行用例驱动测试



> 通过本节，您将学习如何执行手工测试用例、创建缺陷，反馈测试结果。
>
> 背景 
>
> 测试经理：经过开发跟运维的共同努力，现在我们的应用已经可以在迭代内持续的往测试环境部署了，每天都会有新的功能部署到测试环境。大家可以同步的进行软件测试工作，有问题大家及时的反馈，以保证我们迭代交付的质量。

1. 进入项目，单击页面上方导航“测试 > 测试执行”。选择“测试套件”页签，可查看测试套件执行情况，其中,“完成度”表示当前测试套件一共包含多少个测试用例、以及完成了多少个测试用例的执行;“缺陷”表示在执行测试套件的过程中一共创建了多少个缺陷。

   在页面中找到测试套件“迭代4”，单击操作列图标![image-20201022164118296](E:\Typora_Imagine\image-20201022164118296.png)，执行测试套件。==10s==

2. *页面右侧滑框中列出该套件中包含的所有手工测试用例。测试人员按照测试步骤，逐步执行并记录测试结果，根据每个步骤的结果设置测试用例结果；再根据测试用例结果，记录测试套件的执行结果。*

3. 在本节中，我们设定步骤3执行失败，将此步骤结果设置为“失败”，参考下图填写实际测试结果。同时将用例的结果设置为“失败”，并单击图标 ![image-20201022164410446](E:\Typora_Imagine\image-20201022164410446.png)创建缺陷。

   ![image-20201022164435558](E:\Typora_Imagine\image-20201022164435558.png)

   系统将根据执行步骤，自动填充缺陷的重现步骤。参考下图输入缺陷名称、选择模块与迭代，单击“保存”。==1min==

4. 返回“测试执行”页面，按照同样的方式完成其他测试用例的执行，最后设置测试套件的执行结果，单击“保存”。==1min==

5. *套件测试完成，返回列表可查看套件的执行情况（缺陷、结果、完成度）是否与前面步骤中的设置相同。*

   

### 四、使用测试总览跟踪测试进度和质量



> 通过本节，您将学习如何查看项目测试情况，包括需求覆盖率、缺陷、用例通过率、完成率等相关统计。

1. 测试情况分析。进入项目，单击页面上方导航“测试 > 质量报告”。选择“迭代4”，即可查看此迭代的需求覆盖率、缺陷、用例通过率等相关统计。

   ![image-20201022164800867](E:\Typora_Imagine\image-20201022164800867.png)

   如果您在实际练习中所得的报告结果与截图内容不符，请确认您的目标工作项以及测试用例是否都选中了”迭代04“和”门店网络“（或促销网络）模块，并且确保工作项与测试用例都已关联正确。

2. 自定义测试报表。测试经理通过统计度量可以量化高效管理测试团队和测试项目,自定义报表可以帮助创建个性化的统计报表。在“**质量报告**”页面，单击“**新建报表**”，在弹框中选择“**自定义报表**”。输入名称“**所有用例-按结果分组**”，选择工件类型“**测试用例**”、分析维度“**结果**”，单击“**刷新列表**”。当图表刷新出内容后，单击“保存”，新报表将显示在“质量报告”页面中。 ==2min==



**总时长：包括看文档、输入花费时间，20-30分钟。**



## 实验四 持续部署与发布

###  一、使用自动化编译提高代码质量验证速度

> **实验介绍**
>
> 在本实验中，您将学习：
>
> -  如何创建 “编译构建任务”，完成应用的Docker镜像打包以及推送。
> - 如何启动持续集成，实现代码变更后自动触发应用的Docker镜像打包以及推送。
> - 如何使用华为云提供的“开源镜像站”服务提高依赖包获取速度，提高自动化编译效率。
> - 编译构建功能介绍
> - 编译构建（CloudBuild）基于云端大规模并发加速，为客户提供高速、低成本、配置简单的混合语言构建能力，帮助客户缩短构建时间，提升构建效率。
>
> **实验目的**
>
> - 理解并掌握DevCloud编译构建的功能与使用
> - 理解SWR镜像仓库的功能与使用
> - 掌握华为云“开源镜像站”的使用方法



#### 1.编译构建并完成应用的镜像打包推送

> 通过本节，您将学习如何通过“编译构建”服务完成应用的Docker镜像打包以及推送。
>
> 样例项目中预置了以下5个编译构建任务，本章节以任务“phoenix-codecheck-worker”为例进行讲解。
>
> | **预置编译构建任务**     | **任务说明**                   |
> | ------------------------ | ------------------------------ |
> | phoenix-sample-ci        | 基本的编译构建任务。           |
> | phoenix-sample-ci-test   | 测试环境对应的编译构建任务。   |
> | phoenix-sample-ci-worker | worker功能对应的编译构建任务。 |
> | phoenix-sample-ci-result | result功能对应的编译构建任务。 |
> | phoenix-sample-ci-vote   | vote功能对应的编译构建任务。   |

1. 单击页面上方导航“代码>代码托管”，进入样例项目预置的代码仓库“phoenix-sample”，找到”result”目录下的”Dockerfile”文件，打开并编辑第一行：`FROM node:14.5.0-slim` ==2min==

   *// 修改代码时，需输入备注信息。*

2. 查看编译构建任务。进入项目，单击页面上方导航“构建&发布 > 编译构建”，进入编译构建服务。找到编译构建任务“phoenix-sample-ci”。==10s==

3. 单击“phoenix-sample-ci”对应操作列中的图标![image-20201022170006661](E:\Typora_Imagine\image-20201022170006661.png)，进入“编译构建编辑任务”页面。==5s==

4. 点击“**基本信息**”栏，在构建环境主机类型选择”**鲲鹏 (ARM)服务器**”。

5. 点击“**源码选择**”栏，“**仓库分支**”选择”**master**”

6. 配置SWR服务。项目应用镜像存放需要使用到华为云容器镜像服务 (SWR) ，因此需要首先配置SWR服务。点击“**构建步骤**”栏，找到”华为云容器镜像服务”并点击。

   - 此时进入到”**容器镜像服务**”主页，点击立即使用；

   - 检查页面左上方的“**区域**”列表，选择与编译构建任务所在区相同的区域。

   - 单击右上角“**登录指令**”，系统生成并弹框显示docker login指令。

   - 指令中，-u之后的字符串为用户名，-p之后的字符串为密码。

   - 最后的字符串为SWR服务器地址，此地址即为后续步骤8中的参数dockerServer。

   - **记录图中框出的部分。**
   - 在左侧导航栏中选择“**组织管理**”，进入“组织管理”页面。单击右上角“创建组织”，在弹框中输入组织名称“hi-pheonix” (或自定义，此名称全局唯一)，单击“确定”保存。这里的组织名称，即为后续步骤7中的参数dockerOrg。==5min==

7. 返回DevCloud页面，选择“参数设置”页签，编辑以下两个参数。

   - **dockerOrg：输入在步骤6中创建的组织。**
   - **dockerServer：输入在步骤6中记录的内容。**

8. 单击“**保存并执行**”，启动编译构建任务。系统自动跳转至“编译详情”页面，可以查看任务执行进展。当出现以下页面时，表示任务执行成功。请记录“构建成功”字样前面的数字串（即任务的构建编号），该数字串为构建任务中的系统预定义参数BuildNumber，在后续步骤11查看镜像详情中，镜像版本即此数字串。 ==10min==

9. *单击页面上方导航“构建&发布 > **发布**”，进入发布服务。列表中可找到下图所示的两个文件夹。*

10. *进入SWR控制台，在页面左侧导航选择“我的镜像”。列表中可看到5个镜像，镜像的所属组织为实验开始创建的组织，版本数如下图所示。*

11. *在列表中单击“worker”查看镜像详情。在镜像列表页签中找到最新版本镜像，镜像版本与最新一次构建任务的执行编号一致，执行编号的查看方法请参考步骤8。* ==2min==

    

#### 2.配置持续集成并通过提交代码触发自动化编译

> 通过本节，您将学习如何启动持续集成，实现代码变更后自动触发应用的Docker镜像打包以及推送。
>

1. 持续集成配置。进入编译构建任务“**phoenix-sample-ci**”的“**编译构建编辑任务**”页面，选择“**源码选择**”页签，单击“**高级设置**”。单击“**提交代码触发执行**”后的图标，打开开关，单击“保存”。**1min**
2. *持续集成执行计划配置。进入编译构建任务“phoenix-sample-ci”的“编译构建编辑任务”页面。选择“**执行计划**”页签，根据需要设置执行计划，单击“保存”。* ==30s==



#### 3.使用内置的Maven任务改进自动化编译

> 通过本节，您将学习如何使用开源镜像站服务提高依赖包获取速度，提高自动化编译效率。
>
> 背景 
>
> 项目经理：Alex，凤凰商城的持续集成任务，每次执行时间都太长了，分析下什么原因？尽快反馈给我。 
>
> Alex：主要是我们凤凰商城每个服务中都有外部依赖包，包括（maven、npm、nuget、pip）等，这些服务编译过程中都要先下载依赖包，而且由于网络问题，甚至会下载失败导致持续集成失败！ 
>
> 项目经理：OK，那有没有什么好办法解决这个问题？ 
>
> Alex：这些依赖包可以使用我们自己的镜像源，这样速度会就可以达到数量级的提升！ 
>
> 项目经理：太棒了，马上执行！

**通过以下两种配置方式，可以在执行编译构建任务时自动获取开源镜像站中的镜像：** 

- 方式一：使用系统内置的Maven构建、Npm构建、PyInstaller构建步骤，系统会自动通过开源镜像站获取相应的依赖包。

![image-20201022171336158](E:\Typora_Imagine\image-20201022171336158.png)

- 方式二：将镜像源设置为对应的开源镜像站仓库地址配置在代码仓库的配置文件中，查看方式“代码>代码托管>phoenix-sample>文件”。配置方式有以下三种：

  **Python配置方法如下图：** 

![image-20201022171451085](E:\Typora_Imagine\image-20201022171451085.png)

​     **NPM配置方法如下图：** 

![image-20201022171621652](E:\Typora_Imagine\image-20201022171621652.png)

​     **Nuget配置方法如下图所示：** 

​	![image-20201022171701908](E:\Typora_Imagine\image-20201022171701908.png)






























































